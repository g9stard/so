<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>색상표 검출 및 RGB 표시</title>
    <style>
        canvas {
            display: block;
            margin: 0 auto;
        }
    </style>
    <script async src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
</head>
<body>
    <video id="video" controls muted autoplay loop playsinline></video>
    <button id="capture">촬영</button>
    <canvas id="canvas"></canvas>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const context = canvas.getContext('2d');
        const captureButton = document.getElementById('capture');

navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true })
            .then(stream => {
                video.srcObject = stream;
                video.play();
            })
            .catch(err => {
                console.error("카메라 접근 오류: " + err);
            });

        captureButton.addEventListener('click', () => {
            context.drawImage(video, 0, 0, canvas.width, canvas.height);
            processImage();
        });

        function processImage() {
            const src = cv.imread(canvas);
            const hsv = new cv.Mat();
            cv.cvtColor(src, hsv, cv.COLOR_RGBA2HSV);

            // 색상 범위 설정 (예시: 다양한 색상)
            const colorRanges = [
                { name: '빨강', lower: [0, 100, 100], upper: [10, 255, 255] },
                { name: '초록', lower: [40, 100, 100], upper: [80, 255, 255] },
                { name: '파랑', lower: [100, 100, 100], upper: [130, 255, 255] },
                { name: '노랑', lower: [20, 100, 100], upper: [30, 255, 255] }
            ];

            colorRanges.forEach(color => {
                const lowerBound = new cv.Mat(hsv.rows, hsv.cols, cv.CV_8UC3, color.lower);
                const upperBound = new cv.Mat(hsv.rows, hsv.cols, cv.CV_8UC3, color.upper);
                const mask = new cv.Mat();
                cv.inRange(hsv, lowerBound, upperBound, mask);

                // 외곽선 찾기
                const contours = new cv.MatVector();
                const hierarchy = new cv.Mat();
                cv.findContours(mask, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // 외곽선 그리기 및 색상 추출
                for (let i = 0; i < contours.size(); i++) {
                    const boundingRect = cv.boundingRect(contours.get(i));
                    context.strokeStyle = color.name.toLowerCase(); // 외곽선 색상
                    context.strokeRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height);

                    // 평균 색상 추출
                    const avgColor = extractAverageColor(src, boundingRect);
                    context.fillStyle = "black"; // 텍스트 색상
                    context.font = "16px Arial";
                    context.fillText(`${color.name}: RGB(${avgColor.r}, ${avgColor.g}, ${avgColor.b})`, boundingRect.x, boundingRect.y - 5);
                }

                // 메모리 해제
                lowerBound.delete();
                upperBound.delete();
                mask.delete();
                contours.delete();
                hierarchy.delete();
            });

            // 메모리 해제
            src.delete();
            hsv.delete();
        }

        function extractAverageColor(src, boundingRect) {
            let sumR = 0, sumG = 0, sumB = 0, count = 0;

            for (let y = boundingRect.y; y < boundingRect.y + boundingRect.height; y++) {
                for (let x = boundingRect.x; x < boundingRect.x + boundingRect.width; x++) {
                    const pixel = src.ucharPtr(y, x);
                    sumB += pixel[0];
                    sumG += pixel[1];
                    sumR += pixel[2];
                    count++;
                }
            }

            return {
                r: Math.round(sumR / count),
                g: Math.round(sumG / count),
                b: Math.round(sumB / count)
            };
        }
    </script>
</body>
</html>
